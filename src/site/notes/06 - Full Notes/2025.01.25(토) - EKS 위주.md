---
{"dg-publish":true,"permalink":"/06-full-notes/2025-01-25-eks/","dgPassFrontmatter":true,"noteIcon":""}
---

[[03 - Tags/계획표\|계획표]]

---
# 어제 학습 내용 백지 복습
- kvm: 리눅스 시스템에서 가상 머신을 생성하는 소프트웨어 (kernal virtual machine)
- Docker: 컨테이너를 통해서 서로 다른 환경에서도 동일한 시작을 보장
	- Docker는 호스트와 컨테이너가 통신하기 위해 veth(가상 이더넷)를 사용한다.
	- veth는 서로 다른 네트워크 네임스페이스끼리 통신하기 위해 사용되는 기술이다.
- 컨테이너 기술이란?
	- 가상머신은 호스트 시스템과 독립적인 환경을 구성하여 가상머신의 실행 결과가 호스트시스템에 영향을 끼치지 않기 위해 사용한다.
	- 컨테이너 기술은 위처럼 호스트 시스템과 독립적인 환경을 구성한다. (리눅스의 네트워크 네임스페이스나 프로세스 트리 등을 활용해서 논리적으로 구별)
	- 컨테이너는 커널을 가지지 않는다. 반면에, 가상 머신은 가상머신 별로 커널을 가지며 이를 통해 커널 간에 통신이 발생한다. 따라서, 더 느리다.
- 쿠버네티스란?
	- 클러스터 환경에서 조율을 하는 역할
	- 특정 서비스를 Pod 형태로 배포하며 Pod의 스케쥴링은 Control Plane에서 이뤄진다.
	- 스케쥴링은 먼저 노드들을 파악하고, taint 등으로 불가능한 노드들을 제외하며, 점수를 메긴다. 점수가 가장 높은 노드에 Pod를 배포한다.
	- 쿠버네티스는 Control Plane과 Data Plane으로 이뤄진다.
	- Control Plane은 Kube-API Server가 실행 중이며 우리가 실행하는 모든 `kubectl` 명령어들은 kube-api server에 요청으로 전송된다.
	- control plane에선 요청의 인증 정보를 통해서 해당 사용자가 명령어를 사용할 수 있을지 파악한다.
	- Control Plane의 인증 방법으로는 인증서, OIDC 등이 있다.
	- Service는 경로를 기반으로 요청을 라우팅한다.
	- Ingress는 도메인을 처리한다.
	- replicaset은 Pod의 개수를 유지한다.
	- Deployment는 replicaset처럼 Pod 개수 유지와 거기에 더해 Rolling Update 등을 지원한다.
	- Secret은 민감한 정보를 저장할 수 있다. Control Plane에 저장된다. 단, 암호화 되지 않은 상태로 저장되며 Base64를 통해 인코딩된 상태다.
	- Secret은 pod에 마운트 될 수 있다. 이를 통해 Pod에서 해당 정보를 참조할 수 있다.
	- ServiceAccount는 Pod에 신원을 준다.
	- Role과 RoleBinding을 통해서 특정 Role을 ServiceAccount나 User에게 부여 가능하다.
- 네트워크
	- 모듈 나누는 이유:
		- 모듈 별로 개발하여 재사용성을 높이기 위해서
	- 4계층 vs 7계층: 
		- OSI 7계층은 더 세밀하게 나눈 형태로 물리 데이터 네트워크 전송 세션 표현 어플리케이션
		- TCP는 물리 데이터 계층을 합침. 물리 인터넷 전송 어플리케이션이란 4계층으로 나눔. 이를 통해서 어플리케이션 개발에 집중 가능
	- ARP:
		- 브로드캐스트를 통해서 허브에 연결되어 있는 주소에 모든 노드에 패킷을 전송
		- NIC를 통해 해당 주소가 자기 주소가 맞다면 응답
		- 이를 통해서 주소를 파악하고 전달
	- 물리계층: 전기 신호의 전송
	- 데이터계층: 맥 주소로 통신하며 이더넷 등이 있음
	- 네트워크 계층: 주소 ip 등이 있음
	- 전송 계층: TCP UDP
		- TCP 3way handshake를 통해서 연결을 보장. 가상회선 교환 방식으로 가상의 회선을 선정하고 해당 회선을 통해 모든 패킷이 순서대로 전송된다. 따라서, 패킷의 순서가 바뀔 일이 없다.
		- UDP: 다이어그램, 최적의 경로로 라우팅되며 따라서, 패킷의 도착 순서가 달라질 수 이싿.
	- TLS: Transport Layer Security TCP와 SSL이 결합된 프로토콜 HTTPS 등에서 사용한다.
	- HTTPS 과정
		- 서버로 요청하고 인증서를 받는다. 클라이언트는 인증 기관에서 인증서를 확인한 후에 서버로 요청한다.
- AWS
	- EC2
		- AWS AZ에 랙이 있고 거기에 서버들이 수평으로 수십개 깔려있음. 해당 서버에서 특정 스펙을 할당해주는게 EC2
		- 서로 다른 사용자가 같은 하드웨어를 사용할 가능성이 높음
		- 이를 예방하려면 Dedicated Host나 Dedicated Instance 등을 사용하여 Multi Tenant를 방지해야함
		- ssh를 통해 접근할 수 있다. 일반적인 방법
		- Session Manager도 가능
		- AMI를 사용하면 해당 이미지는 이미 셋업 되어 있어서 부트 속도가 빠르다.
		- UserData를 통해서 생성과 동시에 스크립트 실행이 가능.
		- 이를 System Manger의 cfn-init cfn-signal과 같이 사용해서 스크립트 성공적으로 실행 여부를 파악 가능
	- S3
		- 용량은 무제한이다.
		- 글로벌 서비스지만 리전에 만들어진다.
		- One-zone 클래스 제외하고 최소 3개 AZ에 만들어진다.(가용성 및 백업)
		- key를 기반으로 초당 요청 횟수 제한이 있다. GET 등 조회류 5,500  PUT, POST 등 3,500
		- 초과하면 자동으로 스케일링된다.
		- Lifecycle 설정을 통해서 특정 기간이 지나면 Object의 스토리지 클래스 이동 가능
		- Standard, IA, **Glacier**
		- Standard를 제외한 클래스들은 retrieve 비용이 든다.
		- retrieve도 클래스에 따라 시간이 달라진다.
		- Glacier DeepArchive는 최대 12~48시간 걸린다.
		- S3 Notification으로 특정 이벤트에 따라 Lambda를 실행하거나 EventBridge로 알림을 보낼 수 있다.
		- 버켓 정책으로 접근을 제한할 수 있다.
		- Access Point로 경로 기반으로 접근 제한이 가능하다.
		- MultiRegion Access Point로 각 리전 별로 최대 1개 bucket을 등록 가능하다.
		- 이를 통해 제일 빠른 버켓으로 요청을 전송한다.

---
# 오전
- [x] 복습하니 끝남
---
# 오후
- [x] 인프라 구성도 그리기
- [ ] Terraform으로 코드까지 완성

---
# 오늘 학습 내용 백지 복습
- 오랜만에 Terraform 코드 복습하니까 좋았음.
---
# 하루를 마치며
오늘따라 피곤합니다. 일찍 자겠습니다.
집중해서 하나씩 처리해야 되는데 내일은 시작하기 전에 정리하고 작업 들어가겠습니다.
아 내일 친구 만나러감