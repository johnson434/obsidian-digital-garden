---
{"dg-publish":true,"dg-permalink":"system-design/book/system-design-interview-1/chapter01","permalink":"/system-design/book/system-design-interview-1/chapter01/","noteIcon":""}
---

[[03 - Tags/가상 면접 사례로 배우는 대규모 시스템 설계 기초 1권\|가상 면접 사례로 배우는 대규모 시스템 설계 기초 1권]]
# 단서 질문
- 높은 가용성을 보장하기 위해선 데이터센터가 몇 개 필요할까?
	최소 2개 이상이 필요하다. 하나의 AZ가 다운되더라도 서비스를 제공할 수 있어야 한다.
- 캐싱을 사용할 때 주의 사항은?
	캐시 크기를 너무 작게 잡지 않는다. 너무 작다면 Origin으로 요청하는 빈도가 늘어나 Latency가 증가한다.
- CDN이란?
	정적 컨텐츠를 캐싱을 통해 제공하기 위한 서비스
- 데이터베이스의 스케일링 방법은?
	수직 스케일링과 수평 스케일링이 있다. 수직 스케일링은 메모리와 CPU를 증가시키는데 한계가 있으므로 수평 스케일링을 많이 사용한다. 수평 스케일링을 사용할 때, 샤딩을 사용하는데 이 때, 적절한 샤딩 키를 사용할 필요가 있다. 그렇지 않다면 특정 샤드에 데이터가 집중되어 샤드에 재분배가 필요해진다.(resharding) 또한, 자주 질의되는 특정 데이터가 특정 데이터베이스 서버에 몰리게 되면 해당 서버에 질의가 집중되는 현상이 발생된다. 따라서, 이러한 유명인(Celebrity) 데이터는 여러 데이터베이스에 나눠 저장해야 한다.
- Web 서버가 상태를 저장할 필요가 있다. 그러나, 추가적인 데이터베이스를 구성하기엔 예산이 부족하다. 이 때, 해결 방안은? 리소스는 ALB, EC2가 있다.
	Sticky Session을 통해 특정 클라이언트와 특정 서버를 묶는다.
- 로드밸런서의 Sticky Session의 단점은?
	수평 스케일링이 일어나더라도 기존 클라이언트의 요청들이 새로운 서버로 분배되지 않는다. 따라서, 기존 서버들이 더 많은 요청을 처리하고 추후에 추가된 서버들은 비교적 덜 트래픽을 처리한다.
# 핵심 요약
- 가용성을 위해선 최소 2개 데이터센터에 리소스를 구성할 필요가 있다.
- 좋은 확장성은 컴포넌트 간에 의존성을 최대한 줄이고 독립적으로 확장이 가능해야 한다.
- 캐시는 무거운 연산이나 자주 계산되는 요청되는 응답을 캐싱에 저장하여 매 번 새로 요청을 하지 않게 만든다.
- CDN은 Content Delivery Network로 정적 컨텐츠를 캐싱하는데 사용된다.
- 정적 캐싱과 동적 캐싱이 있다.
- 동적 캐싱은 요청 경로, 헤더, 쿠키 등을 통해서 요청을 캐싱할 수 있다.
- 웹 서버는 상태가 없어야 하며 각 요청은 독립적이어야 한다.
- 웹 서버가 상태를 가져야만 한다면 웹 서버가 아닌 외부 저장소에 상태를 기록해야 한다.
- 메시징큐는 서비스 간에 독립적인 확장을 위해 사용된다.
- 메시징큐는 생산자, 메시지 큐, 소비자 3가지 요소로 구성된다.
- 메시지 큐에 메시지는 비동기 통신을 지원한다.
- 메시지 큐를 사용함으로써 서비스 간에 의존성을 줄일 수 있다. (de-coupling)
- 데이터베이스는 수직적 확장도 가능하지만 특정 기준을 넘어서면 비용이 기하급수적으로 늘어난다.
- 데이터베이스의 수평적 확장 방법으로 샤딩이 있다. 이는 데이터를 샤딩 키라는 특정 키값으로 구분하여 여러 개의 데이터베이스 서버에 데이터를 나눠서 저장하는 방식이다.
- 샤딩으로 생길 수 있는 문제점으로 특정 샤딩에 데이터가 집중되어 재분배(resharding)가 필요한 경우와 유명인(celebrity) 문제가 발생할 수 있다.
- 샤딩 재분배는 안정 알고리즘(consistency algorithm)을 통해 해결 가능하다. (5장에서 다룰 예정)
---
# 핵심 필기
## 단일 서버
![Pasted image 20250104182019.png](/img/user/image/Pasted%20image%2020250104182019.png)
- 하나의 서버에 모든 컴포넌트(웹서버, Database)가 존재한다.
- 서버에 장애가 발생하면 모든 컴포넌트가 다운 된다.
---
## 데이터베이스
![Pasted image 20250104181948.png](/img/user/image/Pasted%20image%2020250104181948.png)
- 서버와 데이터베이스를 독립적으로 구성
- 각 컴포넌트가 개별적으로 확장이 가능하다. (ex. DB의 입출력 속도가 느리면 DB 서버만 확장한다.)

**관계형 데이터베이스 vs 비-관계형 데이터베이스**
- 관계형 데이터베이스(relational database)
	- 테이블과 열과 행(row and column)으로 구성된다.
	- 데이터가 정형적이다.
	- SQL을 사용하여 데이터를 조회한다.
- 비관계형 데이터베이스(NoSQL)
	- 관계형 데이터베이스가 아닌 데이터베이스를 총칭하는 말
	- NoSQL 데이터베이스로는 다음이 있다.
		- 키-값 저장소 (key-value store)
		- 그래프 저장소 (graph store)
		- 칼럼 저장소 (column store)
		- 문서 저장소 (document store)
	- 조인을 지원하지 않는다.
**NoSQL을 언제 사용하나?**
- 아주 낮은 응답 지연시간(latency)을 요구
	- 대부분의 NoSQL 데이터베이스는 분산 시스템으로 설계 되어 있어 데이터를 여러 노드에 분산 저장하므로 빠른 읽기/쓰기가 가능하다.
- 다루는 데이터가 비정형(unstructured)이라 관계형 데이터가 아님
- 아주 많은 양의 데이터를 저장할 필요가 있음
	- 데이터를 분산 저장하므로 추가적으로 저장하기 편리하다. (NoSQL은 분산 시스템이므로 단순히 노드를 추가하면 된다. 반면에, SQL 데이터베이스는 분산 시스템이 아니므로 수직적 스케일링이 필요하다. 즉, 확장이 힘들다.)
---
## 수직적 규모 확장 vs 수평적 규모 확장
### 수직적 규모 확장(Vertical Scaling)
![Pasted image 20250104190543.png](/img/user/image/Pasted%20image%2020250104190543.png)
- 단일 호스트의 사양(예: 메모리, CPU 등)을 증가시키는 것을 수직적 규모 확장이라고 한다.
- 사양을 증가시키는 것을 Scale Up이라고 표현하며 반대로 줄이는 것을 Scale Down이라 표현한다.
**장점**
- 관리가 간편하다.
**단점**
- 사양이 증가할수록 비용이 기하급수적으로 증가한다. 
- 수직적 규모 확장에는 한계가 있다. (한 대의 서버에 CPU나 메모리를 무한대로 증설할 수 없다.)
- 서버가 죽으면 모든 서비스가 죽는다. (SPOF: Single Point Of Failure)
### 수평적 규모 확장(Horizontal Scaling)
![Pasted image 20250104191514.png](/img/user/image/Pasted%20image%2020250104191514.png)
- 서버를 추가하는 것을 수평적 규모 확장이라고 한다.
- 서버의 개수를 증가시키는 것을 Scale Out이라고 표현하며 반대로 줄이는 것을 Scale In이라고 한다.
- 분산 시스템(Distributed System)이나 무상태 시스템(Stateless System)만 적용 가능하다.
**장점**
- 특정 서버에 장애가 발생했을 시, 다른 서버가 서비스를 처리한다. (높은 가용성)
- 수직적 규모 확장보다 쉽게 확장이 가능하다. (높은 확장성)
**단점**
- 서버가 여러 개이므로 복잡성이 증가한다. (클러스터를 관리할 수 있는 쿠버네티스가 요즘 각광 받는 이유이기도 하다.)
### 로드밸런서
![Pasted image 20250104205153.png](/img/user/image/Pasted%20image%2020250104205153.png)
- 로드밸런서는 들어오는 트래픽을 분산 알고리즘에 맞춰서 분배합니다.
- 로드밸런서는 주기적으로 서버의 상태를 확인합니다. (Health Check)
- 서버의 상태가 건강하지 않다면(Unhealthy) 해당 서버로는 트래픽을 보내지 않습니다.
- 서버의 건강을 판단하는 기준은 아래와 같습니다.
	- ALB(Application Loadbalancer): 특정 경로로 HTTP 요청을 보내고 응답이 특정 HTTP 코드면 건강하다고 판단합니다.
		- 예: http://10.0.0.1/health 경로로 요청을 보내고 응답 HTTP Status Code가 200이면 건강하다고 판단. (요청 경로와 응답 코드는 커스텀하게 설정 가능하다.)
---
### 데이터베이스 다중화
![Pasted image 20250104205924.png](/img/user/image/Pasted%20image%2020250104205924.png)
- 데이터베이스는 다중화를 위해 일반적으로 위와 같이 Master-Slave 구조를 취합니다.
- Master는 읽기, 쓰기가 가능하며 Slave는 읽기만 가능합니다.
**데이터베이스 다중화의 이점**
- 성능: 읽기 작업을 Slave 데이터베이스에서 분산 처리하므로 더 빠른 조회 성능을 보장한다.
- 안정성(reliability): 특정 서버가 파괴되어도 다른 서버에 동일한 데이터가 저장되므로 데이터를 보존할 수 있다.
- 가용성(availability): 서비스 중인 서버가 파괴되거나 장애가 생겨도 다른 서버에서 데이터를 조회할 수 있다.
	- Active-StandBy: 하나는 서비스를 제공하고 하나는 대기 중이다가 Active 중인 서비스에 문제가 생기면 대기 중이던 StandBy 서버가 대신 서비스를 제공한다.
	- Active-Active: 두 개의 서비스가 동시에 서비스를 제공한다.
---
## 캐시
캐시(Cache)는 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리에 저장해두어 결과 값을 바로 반환해주는 역할입니다. 사용자가 요청하는 결과 값이 캐시에 있다면 서버나 DB에 요청할 필요 없이 캐시에서 바로 반환합니다. 
### 캐시 계층 
![Pasted image 20250105171042.png](/img/user/image/Pasted%20image%2020250105171042.png)
- 위의 그림은 AWS의 CloudFront를 Caching으로 사용한 예시입니다.
- Client로부터 들어오는 요청이 CloudFront에 캐싱 된 상태라면 Server에 요청하지 않고 바로 CloudFront에서 결과를 반환합니다.
**캐싱 시 주의 사항**
- 갱신이 자주 일어나지 않지만 참조는 빈번할 때 사용한다.
- 캐싱 만료 기한을 설정한다. (너무 길면 원본이 바껴도 잘못된 데이터를 참조할 수 있고 너무 짧으면 캐싱을 위해 데이터베이스를 읽는 주기가 짧아진다.)
- 일관성(consistency)에 대한 고려가 필요하다. 원본 데이터 갱신과 캐싱 데이터 갱신이 하나의 트랜잭션으로 이뤄지지 않는다면 캐싱과 원본 데이터 조회 시점에 따라 서로 다른 데이터를 조회할 수 있다. -> 일관성을 해친다.
	- 일관성에 대해선 페이스북에서 내놓은 논문 Scaling Memcache(https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf)를 참고하라.
- 캐시를 통해서 모든 요청이 전달되면 캐시 서버가 SPoF가 될 수 있다. 
		![Pasted image 20250105171032.png](/img/user/image/Pasted%20image%2020250105171032.png)
	- CloudFront는 가용성을 99.9% 보장하지만 그 이상 보장하기 위해선 여러 개의 오리진을 사용하면 된다. (최소 2개 이상)
- 캐시 메모리의 크기에 고려가 필요하다. 너무 작으면 캐시에서 자주 밀려나와(eviction) 캐시의 성능이 떨어질 것이다. 최대한 크게 잡되 비용까지 고려하자.
- 캐시 방출 정책이 필요하다. LRU(Least Recently Used), LFU(Least Frequently Used), FIFO(First In First Out) 등이 있다.
---
## 콘텐츠 전송 네트워크(CDN)
CDN(Content Delivery Network)은 이미지, 비디오, CSS, JS 파일과 같은 정적 컨텐츠를 캐싱 및 전송하는 데 쓰인다.
동적 컨텐츠 캐싱(Dynamic Content Caching)은 요청 경로, 쿼리스트링, 쿠키, 요청 헤더 등의 정보를 기반으로 HTML 페이지를 캐싱한다.
![Pasted image 20250105163311.png](/img/user/image/Pasted%20image%2020250105163311.png)
**CDN 사용 시 고려 사항**
- 비용: CDN을 통해 들어가고 나가는 데이터 전송 양에 따라 요금을 낸다. 자주 사용되지 않는 컨텐츠는 캐싱하지 말자.
- 적절한 만료 시한 설정: TTL을 통해 캐싱 기간을 설정할 수 있다. 너무 길다면 Cache Eviction이 자주 발생한다. 만약, 반대로 너무 짧다면 오리진에 데이터를 요청하는 횟수가 증가할 것이고 이는 Latency를 증가시킨다. 
- CDN 장애 대처 방안: 일시적으로 CDN에 장애가 발생했을 시에 원본 서버로부터 직접 컨텐츠를 가져오도록 구성
---
## 무상태(stateless) 웹 계층
수평적으로 웹 계층을 확장하기 위해서 웹 계층은 상태 정보를 가지면 안 된다. 
예시를 들어보겠다. A 서버가 있는 상태에서 트래픽이 급증하여 수평적 스케일링을 통해 서버 B가 추가 되었다고 생각해보자. 만약, 웹 계층에서 상태 정보를 제거하지 않은 상태라면 클라이언트가 서버 A와 네트워킹하는 과정에서 서버 A에 세션 정보가 저장되었을 것이다. 
이 때, 클라이언트가 다시 요청을 보내면 로드밸런싱을 통해서 서버 A가 아닌 서버 B로 요청을 보내게 된다. 서버 B엔 세션 정보가 저장되어 있지 않으며 서버 A로 요청했을 때와 다르게 동작할 것이다. 아래 그림을 보자.
![Pasted image 20250105173849.png](/img/user/image/Pasted%20image%2020250105173849.png)
각 서버의 정보가 일치하지 않아 동일한 요청이어도 결과 값이 달라진다.
이를 해결하기 위해서 sticky session을 사용하기도 한다.


![Pasted image 20250105174237.png](/img/user/image/Pasted%20image%2020250105174237.png)
Sticky Session은 위 그림처럼 특정 클라이언트는 특정 서버에 요청을 보내도록 묶는다. AWS ALB에선 Cookie 기반으로 Sticky Session을 지원한다.
단, Sticky Session도 단점이 존재한다. Sticky Session 자체에 오버헤드도 있겠지만 이와 별개로 로드밸런싱이 어려워진다. 특정 Client는 자신과 묶인 서버로 계속 요청을 보낼 것이고 이는 균형 잡힌 트래픽 분배를 힘들게 한다.

**무상태 아키텍처**
따라서, 웹 계층엔 상태 정보를 저장하지 않아야 한다. 만약에, 어떻게 해도 상태를 저장할 필요가 있다면 공유 저장소(shared storage)를 사용하여 해당 저장소에 상태를 저장하는 게 좋다.
![Pasted image 20250105175745.png](/img/user/image/Pasted%20image%2020250105175745.png)
위 그림에선 확장성이 좋은 DocumentDB를 공유 저장소로 사용했지만, 공유 저장소로는 무엇을 사용해도 상관 없다.(RDBMS, Memcached, Redis, ...)

---
## 데이터 센터
높은 가용성을 가지기 위해서는 최소 2개의 서로 다른 장소에 데이터센터를 이용합니다. 
하나의 데이터센터에 문제가 발생하더라도 서비스를 제공하기 위해서입니다. 
다중 데이터센터 아키텍처를 만들기 위해선 다음과 같은 기술적 난제를 해결해야 합니다.
1. 트래픽 우회: 올바른 데이터 센터로 트래픽을 보내는 효과적인 방법을 찾습니다. Route53에선 gelocation 정책을 통해서 사용자와 가장 가까운 AWS 리소스로 트래픽을 포워딩할 수 있습니다.
2. 데이터 동기화(Synchronization): 데이터센터 별로 데이터베이스를 사용하는 경우엔 데이터베이스 간에 동기화가 필요합니다.
3. 테스트와 배포: 자동화된 배포 도구를 통해서 모든 데이터 센터에 동일한 서비스가 설치되도록 하는 데 중요한 역할을 합니다.
---
## 메시지 큐
시스템을 더 큰 규모로 확장하기 위해서는 시스템의 컴포넌트를 분리하여 독립적으로 확장할 수 있어야 합니다. 이러한 분산 시스템의 확장을 해결하기 위해서 메시지 큐(message queue)라는 전략을 사용합니다.
- 비동기 통신을 지원하며 메시지의 버퍼 역할을 합니다. 
- 기본 아키텍처는 생산자, 메시지큐, 소비자로 구분됩니다. 생산자는 메시지를 메시지 큐에 발행하며 소비자는 메시지를 구독하며 해당 메시지를 소비합니다.
- 서비스 간에 결합이 느슨해집니다. A 서비스와 B 서비스가 통신한다고 가정했을 때, 메시지 큐가 없다면 어느 한쪽이 다운된 경우에 서비스가 동작하지 않습니다. 그러나, 메시지 큐를 사용한다면 메시지 큐가 동작하는 한 생산자나 소비자 둘 중에 어느 한쪽이 다운되더라도 문제가 발생하지 않습니다.
메시지 큐의 예로는 RabbitMQ, AWS SQS, Redis 등이 있습니다.
![Pasted image 20250105195546.png](/img/user/image/Pasted%20image%2020250105195546.png)
첫번째 그림은 **B 서비스가 중단된 상황을 가정**했습니다. 이 상황에서 A 서비스는 B 서비스가 복구되길 기다리거나 작업을 취소해야 합니다.
두번째 그림도 **동일하게 B 서비스가 중단**됐지만 SQS라는 메시지 큐 서비스가 제공되는 상태입니다. 이 상황에 A 서비스는 단순히 메시지 큐에 메시지를 저장하고 다른 일을 처리하면 됩니다.

---
## 로그, 메트릭 그리고 자동화
서비스의 로그를 기록하여 에러를 쉽게 찾고, 메트릭을 통해서 호스트의 상태(CPU 사용량, Memory 사용량, 네트워크 대역폭 등)나 일별 능동 사용자(DAU)와 같은 정보를 관측하여 데이터 기반으로 비즈니스 방향성을 정할 수 있습니다. 또한, 자동화를 통해서 코드 통합부터 배포까지 자동으로 진행 가능합니다.
최근엔 MSA 구조를 택하는 회사가 늘어나면서 Tracing(추적)에 대한 중요도도 높아지고 있습니다. Tracing이란 요청(request)이 어떤 서비스에서 어떤 서비스까지 얼마나 소요됐고 DB에서 얼마나 소요됐는지 등 요청의 경로를 추적합니다. 예를 들어, 사용자가 결제를 했을 때 회원 서비스 -> 상품 서비스 -> 결제 서비스 이런 식으로 호출이 된다면 각 서비스 간에 호출에 얼마나 시간이 걸렸는지 추적이 가능합니다.
![Pasted image 20250105201421.png](/img/user/image/Pasted%20image%2020250105201421.png)
위 이미지처럼 추적이 가능하므로 어느 서비스에서 문제가 발생했는지 또는 보틀넥이 어디인지 파악이 쉽습니다.

---
## 데이터베이스의 규모 확장
데이터베이스의 규모 확장 방법으로는 앞에 말한 것처럼 수직적 규모 확장과 수평적 규모 확장이 있습니다. 
수직적 규모 확장은 CPU나 Memory 등 단일 시스템의 스펙을 증가시키는 것입니다. 단, 앞에서 말했던 것처럼 수직적 규모 확장에는 문제점이 있습니다.
1. CPU, Memory를 무한대로 증설할 수는 없다. 
2. SPOF 문제가 생긴다.
3. 고성능 서버로 갈수록 비용은 기하급수적으로 증가한다.
위와 같은 단점 때문에 수평적 확장을 고려해야 합니다.

**수평적 확장**
수평적 확장은 샤딩(sharding) 기법을 통해서 가능합니다. 데이터를 여러 개에 데이터베이스에 나눠서 저장하는 방식입니다.
예를 들어서, 유저 정보를 저장하는 데이터베이스가 있고 이를 4개의 데이터베이스로 샤딩한다고 가정하겠습니다. 또한, 유저의 ID는 정수형으로 저장된다고 가정하겠습니다. 이 상태에선 유저의 ID를 4로 나눈 나머지에 따라서, 데이터베이스를 나눠서 저장할 수 있습니다.
![Pasted image 20250105202153.png](/img/user/image/Pasted%20image%2020250105202153.png)
이 때, 데이터 샤딩에 사용된 user_id를 샤딩 키라고 합니다.
그러나, 샤딩에도 다음과 같은 문제점이 발생합니다.
1. 데이터의 재 샤딩(resharding): 특정 샤딩에 데이터가 많이 저장되어 샤드 간 데이터 분포가 균등하지 못한 경우에 샤딩 키를 변경하거나 함수를 변경하여 함수를 재배치한다. 안정해시(consistent hashing)을 통해서 이 문제를 해결 가능하다.
2. 유명인사(celebrity) 문제: 특정 데이터에 질의가 집중되어 해당 데이터베이스 서버에 과부하가 생기는 문제. SNS를 예로 들면, 저스틴 비버와 같은 유명인사에게 질의가 자주 걸릴 것이다. 이는 저스틴 비버가 저장된 샤딩 데이터베이스의 질의가 집중되는 경향이 생길 것이다. 이를 해결하기 위해선 유명인사를 샤딩 별로 나누거나 더 잘게 쪼게야 할 수도 있다.
3. 조인과 비정규화(join and de-normalization): 여러 샤드에 걸친 데이터끼리 조인은 힘들다. 이를 해결하는 한 가지 방법으로 데이터베이스를 비정규화하여 하나의 테이블에서 질의가 수행되도록 하는 것이다. (예: 유저 테이블과 주문 테이블을 하나의 테이블로 만든다. 이를 통해 조인을 하지 않아도 된다.)
---
