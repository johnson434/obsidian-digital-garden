---
{"dg-publish":true,"permalink":"/06-full-notes/g-rpc-vs-rest-api/","noteIcon":""}
---

[[03 - Tags/gRPC\|gRPC]] [[03 - Tags/Rest API\|Rest API]]
# 핵심 요약
- gRPC는 HTTP 2를 사용하며 데이터 형식은 Binary.
- REST API는 HTTP 1.1을 사용하며 데이터 형식은 JSON 혹은 XML
- gRPC는 양방향 통신 가능하지만 REST API는 단방향 통신만 지원한다.
# 단서 질문
- gRPC의 데이터 형식은?
    Binary 데이터로 데이터 변환이 필요 없어 빠르다.
- gRPC와 Rest API가 사용하는 프로토콜은?
    gRPC는 HTTP2를 사용하며, Rest API는 HTTP 1.1을 사용한다.

# 핵심 필기
## gRPC란?
_**gRPC**_(_**gRPC**_ Remote Procedure Calls) 구글에서 만든 원격 프로시저 호출로 HTTP 2를 사용하여 기본적으로 암호화를 사용한다. 또한, 데이터를 Binary로 주고 받으므로 RestAPI처럼 JSON 문자열을 파싱/언파싱하는 과정이 없다.
## RestAPI란?
HTTP 1.1을 사용하여 HTTP 메소드와 URL을 통해 액션을 지정한다.
### 공통점 및 차이점
|                    |                                    |                             |                                                                              |
| ------------------ | ---------------------------------- | --------------------------- | ---------------------------------------------------------------------------- |
| **항목**             | **gRPC**                           | **REST API**                | **비교**                                                                       |
| **프로토콜**           | HTTP/2                             | HTTP/1.1                    | gRPC는 HTTP/2를 사용해 더 빠르고 효율적이며, REST는 HTTP/1.1을 사용함.                          |
| **데이터 형식**         | Protocol Buffers (protobuf, 바이너리)  | JSON, XML (주로 JSON)         | gRPC는 바이너리 형식으로 더 작고 빠름. REST는 JSON을 사용하여 사람이 읽기 쉬우나 더 많은 대역폭을 소모함.          |
| **속도/성능**          | 매우 빠름 (바이너리 전송, HTTP/2의 멀티플렉싱)     | 상대적으로 느림 (텍스트 전송, HTTP/1.1) | gRPC는 더 나은 성능을 제공, 특히 대규모 마이크로서비스 또는 실시간 통신에 유리함.                            |
| **API 정의 및 인터페이스** | `.proto` 파일로 명확하게 정의               | 자율적이고 유연함                   | gRPC는 엄격한 API 정의 파일을 사용하며, REST는 자유롭지만 덜 명확함.                                |
| **동기/비동기 지원**      | 기본적으로 동기와 비동기 모두 지원                | 기본적으로 동기 (비동기는 추가 구현 필요)    | gRPC는 비동기 호출이 기본적으로 가능, REST는 추가 설정이 필요.                                     |
| **스트리밍**           | 클라이언트-서버 간 양방향 스트리밍 가능             | 스트리밍 지원은 제한적 (서버-클라이언트 단방향) | gRPC는 양방향 스트리밍을 지원하여, 실시간 데이터 통신에 매우 적합. REST는 스트리밍에 적합하지 않음.                |
| **사용 사례**          | 마이크로서비스 간 통신, 실시간 서비스              | 웹 API, 애플리케이션과의 통합          | gRPC는 마이크로서비스, IoT, 실시간 채팅, 비디오 스트리밍에 적합. REST는 웹과 모바일 애플리케이션과의 통신에 적합.      |
| **플랫폼 및 언어 지원**    | 여러 언어 지원 (C++, Go, Java, Python 등) | 대부분의 언어 및 플랫폼에서 지원          | gRPC는 다중 언어에서 네이티브로 지원. REST는 거의 모든 플랫폼에서 쉽게 구현 가능.                          |
| **보안**             | 기본적인 TLS 암호화                       | HTTPS를 통해 암호화 가능            | 둘 다 보안에 있어 차이는 없으나, gRPC는 HTTP/2를 기본적으로 사용하여 추가적인 보안 강화 옵션 제공.               |
| **확장성**            | 높은 확장성 (HTTP/2 및 멀티플렉싱 덕분에)        | 중간 정도                       | gRPC는 확장성이 더 뛰어나며, 특히 마이크로서비스 아키텍처에서 많은 연결을 처리하는 데 더 적합.                     |
| **브라우저 지원**        | 제한적 (gRPC-web 필요)                  | 브라우저에서 직접 지원                | REST는 브라우저에서 바로 사용할 수 있지만, gRPC는 브라우저에서 직접 사용할 수 없어 별도의 gRPC-web 라이브러리가 필요함. ||

## 언제 무엇을 사용할지
| **상황**                  | **gRPC 사용 추천**                                     | **REST 사용 추천**                               |
| ----------------------- | -------------------------------------------------- | -------------------------------------------- |
| **마이크로서비스 간 통신**        | 성능과 효율성을 중요시하는 마이크로서비스 간의 통신에 적합                   | 단순한 데이터 처리 및 비즈니스 로직에 적합                     |
| **실시간 데이터 통신**          | 실시간 채팅, 비디오 스트리밍, IoT 등 고속 통신이 필요한 서비스에 적합         | 실시간 통신보다는 요청-응답 기반의 데이터 처리가 더 적합             |
| **대규모 시스템 및 고성능 요구**    | 대규모 시스템에서 성능과 대역폭 최적화가 중요한 경우 (예: 분산 시스템, 고성능 시스템) | 성능이 덜 중요한 시스템 (예: API 서버, 데이터 제공 웹 애플리케이션)   |
| **브라우저 기반의 클라이언트**      | 브라우저 클라이언트를 주로 다루지 않거나 gRPC-web을 사용할 수 있는 경우       | 브라우저에서 직접 사용할 수 있어야 하는 경우                    |
| **언어에 구애받지 않는 API 통신**  | 강력한 언어 지원과 프로토콜 간의 통신이 중요한 경우 (다양한 언어 간의 통합)       | 자율적인 API 설계가 필요하거나 다양한 기술 스택에서 간편하게 통합해야 할 때 |
| **확장성 및 고성능이 중요한 경우**   | 대규모 데이터 처리와 멀티플렉싱, 비동기 호출이 중요한 경우                  | 단순한 요청-응답 처리와 낮은 수준의 확장성이 필요한 경우             |
| **서비스 버전 관리 및 API 명확성** | 명확한 인터페이스 및 서비스 버전 관리를 중시하는 경우 (protobuf로 정의)      | 버전 관리보다는 유연한 API 설계가 필요한 경우                  |
