---
{"dg-publish":true,"permalink":"/06-full-notes/1/","dgPassFrontmatter":true}
---

# Tags
[[06 - Full Notes/1부 스토리지 엔진\|1부 스토리지 엔진]]

---
# 단서 질문
- 컬럼형 DBMS를 쓰는 이유는?
	- 집계를 자주 사용할 경우에
- 로우형 DBMS를 쓰는 이유는?
	- 특정 레코드를 자주 조회하는 경우에
- 인메모리 DB와 디스크 기반 DB 선택 기준은?
	- 날아가도 크게 문제없는 데이터일 경우엔 인메모리 써도 좋고 
	- Latency가 빠르길 원하면 인메모리 써도 좋고
	- 데이터가 더 안정적으로 저장되어야 한다면 디스크 기반이 좋고
---
# 핵심 요약
- 데이터베이스는 크게 인메모리DB와 디스크 기반 DB로 분류된다.
- 인메모리 DB는 데이터를 모두 메모리에 저장하며 따라서, 빠른 읽기 쓰기가 가능하다. (캐싱 서버 Redis, Memcached)
- 대신 Application에서 오류가 발생하여 다운되면 모든 데이터가 날아간다.
- 이를 위해 비정전 메모리나 배터리 메모리를 사용한다.
- 이는 유지보수 비용을 증가 시킨다.
- 현재 비휘발성 주기억장치가 개발중이다. (NVM)
- 디스크 기반 DB의 경우엔 데이터를 모두 보조 기억 장치에 저장한다.(SSD, HDD)
- 주 기억장치는 캐싱용으로 사용한다.
- 서버가 다운되어도 비휘발성 저장 장치이므로 데이터가 날아가지 않는다.
- 컬럼형 데이터베이스는 데이터를 컬럼 기반으로 데이터를 저장한다.
- 따라서, 집계에 유용하다.
- 로우형 데이터베이스는 데이터를 로우 기반으로 저장한다.
- 따라서, 하나의 레코드를 조회하기에 유용하다.
- 테이블을 데이터 파일에 저장된다.
- 인덱스는 별개의 인덱스 파일에 저장된다.
- 테이블 저장방식에 따라 Index Organized Table, Heap Organized Table, Heap Organized Table이 있다.
---
# 핵심 필기
## 1부 스토리지 엔진
- 데이터베이스는 모듈식 시스템으로 전송 계층과 쿼리 프로세서, 실행 엔진과 스토리지 엔진으로 이뤄진다.
- 전송 계층은 DB로 들어오는 요청을 전송
- 쿼리 프로세서슨 쿼리 실행 순서를 결정
- 실행 엔진과 스토리지 엔진에선 실제로 들어온 요청에 대한 연산을 실행한다.
- 스토리지 엔진은 키와 값을 바이트 시퀀스로 취급하므로 키가 ascii이든 int32이든 어떤 자료이든 직렬화(이진 숫자)로 파악한다.
### 데이터베이스 비교
- 데이터베이스를 고르려면 미리 사전의 다음과 같은 변수를 정의하고 비교해야 한다.
	- 읽기 쓰기 작업의 비율
	- 스키마와 레코드 크기
	- 쿼리 형식과 접근패턴
	- 클라이언트 수
	- 위 변수들의 변동폭
### 장단점 비교
- 스토리지 엔진은 C 언어부터 Java까지 다양한 언어로 만들어졌다.
- 완벽한 엔진은 없으며 Trade-off가 발생한다.

## 1장 소개 및 개요
- DB는 특성에 따라 다양한 분류 방법이 있다.
- 저장 매체에 따라 분리, 레이아웃 관점(컬럼형, 로우형) 등 다양하다.
### DBMS 구조(스킵)
- 전송 계층 <-> 쿼리 계층(쿼리 파서, 쿼리 옵티마이저) <-> 실행 계층 <-> 스토리지 엔진(트랜잭션 매니저, 잠금 매니저, 액세스 메소드, 버퍼 매니저, 복구 매니저)
### 인메모리 DBMS 대 디스크 기반 DBMS
#### 인메모리 DB
- 주 기억장치인 휘발성 메모리(Volatile Memory)에 데이터를 저장한다.
- 보조 기억장치엔 백업이나 로그를 저장한다.
- 휘발성이므로 Application 에러가 났을 때, 모든 데이터가 날라갈 가능성이 있다.
- 따라서, 추가적인 무정전 메모리나 배터리 장착 RAM 등을 사용한다.
- 이는 관리 비용이 증가하는 경향이 있다.
- 메모리에서 읽기/쓰기를 하므로 Latency가 디스크 기반에 비해 작다.
- 추후에 비휘발성 메모리(NVM) 기술이 대중화된다면 더 많이 쓰일 수 있다.
#### 디스크 기반 DB
- 보조 기억장치에 데이터를 저장한다.
- Application 에러가 발생해도 전체 데이터가 날아가지 않는다.
- 주 기억장치는 캐싱으로 사용한다.
### 인메모리의 지속성
- 작업에 대한 로그 기록을 보조 기억 장치에 저장한다.
- I/O 작업을 최소화하기 위해서 배치 작업을 통해서 로그를 기록한다.
- 이러한 스냅샷을 남기는 것을 체크포인트를 남긴다고 표현한다.
### 칼럼형 DBMS 대 로우형 DBMS
#### 칼럼형 DBMS(Column Oriented Database)
- 컬럼을 기준으로 데이터를 저장한다.
- **집계에 유용**하다. (하나의 블록에 모든 데이터가 들어있으니까)
- 한 사람의 데이터를 전부 조회하는 건 느릴 것이다. (컬럼끼리 서로 다른 블록이라서 조회가 힘들어짐)
#### 로우형 DBMS(Row Oriented Database)
- 여러 필드의 값을 고유 식별 키(Primary Key 순차적으로 증가하는 수)로 구분할 수 있는 레코드 형식에 적합하다.
- 로우 기준으로 저장하므로 **특정 1명의 데이터 관련 작업은 쉽다.** 
- 여러 명을 가져오는 건 힘들다. (데이터 블록의 연속적으로 특정 데이터가 배치된다. 따라서, 특정 데이터의 전체 컬럼을 조회하는 건 빠를 것이다. 그러나, 여러 개의 데이터를 조회하기 위해선 서로 다른 데이터 간에 블록의 간격이 길어진다. 왜냐하면 데이터 사이에 필요하지 않은 컬럼이 배치되어 있으므로)
![Pasted image 20250117173626.png](/img/user/image/Pasted%20image%2020250117173626.png)
#### 차이점과 최적화 기법
- 위는 데이터의 레이아웃이며 컬럼형 데이터베이스와 로우형 데이터베이스를 위 방법으로만 단순하게 구분하진 않는다.
- 컬럼형 데이터베이스의 장점은 데이터베이스 압축률도 있다. 하나의 볼륨에 동일한 자료형으로 데이터가 저장되므로 일관적으로 압축 가능하다.
#### 와이드 칼럼 스토어(스킵)
- 다차원 맵 형식으로 저장한다.
- 컬럼 패밀리(아래 예시로 생각하면 contents랑 anchor끼리)끼리 데이터를 저장하는 방식
```
{
	"contents": {
		"anchor": {
			"1": "abc",
			"2": "dddd"
		}
	}
}
```
### 데이터 파일과 인덱스 파일
- 테이블은 별도의 파일에 저장된다.
- 인덱스도 별도의 파일에 저장된다.
- 인덱스를 통해서 레코드의 위치를 찾을 수 있다.
- 인덱스 조회 -> 레코드의 위치 확인 -> 테이블 파일 -> 레코드 위치 조회
#### 데이터 파일
- 데이터 파일은 인덱스 구조형 테이블, 힙 구조형 테이블, 해시 구조형 테이블이 있다. (Index-Organized-Table, HOT, HOT)
- 힙 구조형은 삽입하는 순서대로 데이터를 넣는다. 단, 인덱스의 실제 데이터의 위치가 있어야 한다.
- 해시 구조형은 말 그대로 해시함수를 통해 데이터를 저장한다. 키의 해시 함수를 저장하여 해당하는 버킷에 저장한다. 버킷 내 레코드는 삽입 순서대로 저장하거나 키 순서로 정렬하면 조회속도가 향상된다.
- 인덱스 구조형은 인덱스에 실제 데이터를 저장한다. (인덱스와 함께 레코드가 저장됨. 따라서, 데이터 파일을 찾으러 갈 필요가 없다.)
#### 인덱스 파일(스킵)
#### 기본 인덱스를 통한 간접 참조(스킵)
### 버퍼링과 불변성, 순서화(스킵)
---
# 참고 자료





