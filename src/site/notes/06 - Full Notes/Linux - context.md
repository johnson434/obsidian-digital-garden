---
{"dg-publish":true,"permalink":"/06-full-notes/linux-context/","noteIcon":""}
---

# Tags
- [[03 - Tags/Linux\|Linux]]
---
# 핵심 요약
- **Interrupted Context**:
		인터럽트가 발생했을 때, 현재 실행 중인 프로세스를 일시 중단하고, 운영 체제의 인터럽트 서비스 루틴(ISR)으로 제어가 넘어갑니다. 이때, 프로세스에서 사용하고 있던 레지스터나 상태 정보들을 저장해야 하므로, 이를 "interrupted context"라고 합니다. ISR을 실행한 후에는 원래 프로세스로 복귀해야 하기 때문에, 해당 프로세스의 상태를 다시 복원하는 작업이 필요합니다. 이 상태를 보존하는 과정이 바로 interrupted context입니다.
- **Process Context**:
		프로세스 컨텍스트는 특정 프로세스가 실행될 때 그 프로세스의 상태를 나타냅니다. 이는 CPU 레지스터, 프로그램 카운터, 스택 포인터 등 해당 프로세스의 실행 상태를 포함합니다. 프로세스가 실행되는 동안 이 정보는 계속해서 CPU에 의해 처리됩니다. 이 상태 정보가 "process context"입니다. 이 정보는 프로세스 스위칭(컨텍스트 스위칭) 시에 저장되고 복원됩니다.
		즉, **interrupted context**는 인터럽트가 발생하여 현재 프로세스를 일시 중단하고 인터럽트 처리 루틴을 실행하는 동안의 상태를 나타내고, **process context**는 정상적인 프로세스 실행 중에 프로세스의 상태를 나타내는 것입니다.
		인터럽트 처리 과정에서 프로세스의 상태를 보존하고 복원하는 것이 핵심 차이점입니다.
---
# 핵심 필기
## Execution contexts
- 실행 문맥엔 `interrupt context`와 `process context`가 존재한다. 
- 리눅스 커널의 가장 중요한 job은 인터럽트 서비스다.
- 커널이 인터럽트를 통해 인터럽트 서비스 루틴을 실행하면 해당 작업을 기록하는 인터럽트 문맥(interrupt context)을 가진다.
- 인터럽트 문맥엔 인터럽트 핸들러와 인터럽트 모드에서 동작하는 특수한 소프트웨어가 포함된다.
- 인터럽트 문맥에서 실행되는 코드는 항상 커널 모드에서 동작하지만 제한 사항이 존재한다.
	- blocking function을 호출하지 못한다. [^1]
	- user space에 접근이 불가능하다.
- 프로세스 문맥은 인터럽트 문맥과 반대된다.
- 프로세스 문맥에서 실행되는 코드들은 `user mode`로 어플리케이션 코드를 실행하거나 `kernel mode`로 시스템 호출을 할 수 있다. 인터럽트 문맥과 달리 `kernel mode`를 통해서 할 수 있는 일은 시스템 호출 밖에 없다.
> [!인터럽트란?]
> 인터럽트는 CPU가 급히 필요한 작업이 생길 때, 커널이 인터럽트 신호를 수신하여 CPU를 즉시 사용하는 용도다. 동기 인터럽트와 비동기 인러텁트가 있는데 동기 인터럽트는 프로세스에서 발생하는 Exception 등 비동기 인터럽트는 입출력 장치에서 발생하는 인터럽트다. 이전에 컴퓨터구조와 운영체제를 공부할 때, 인터럽트 서비스 루틴이 나온다. 이 인터럽트 서비스 루틴이 바로 인터럽트 핸들러다.
## Multi-tasking
멀티태스킹은 운영체제에서 여러 개 프로그램을 통시에 실행하는 기능이다. 빠른 속도로 여러 프로세스를 전환함으로써 동시에 프로세스가 실행되는 것처럼 보인다.[^2]
선점형 멀티태스킹(Preemptive multitasking)에선 커널에서 프로세스마다 엄격하게 실행을 제한한다. 각 프로세스는 일정 시간(예: 100ms) 동안 실행되며, 타이머 인터럽트가 발생하면 강제로 다른 프로세스로 전환된다.
## Preemptive kernel
`선점형 멀티태스킹(Preemptive multitasking)`과 `선점형 커널(Preemptive kernel)`은 다른 의미다.
선점형 커널은 **`커널 모드`를 통해 실행 중인 프로세스**를 중간에 멈춤으로써 다른 프로세스를 실행할 수 있습니다.
비선점형 커널은 **`커널 모드`로 실행 중인 프로세스**를 선점할 수 없습니다. 
그렇지만 **`유저 모드`로 실행되는 프로세스**는 선점이 가능하므로 선점형 멀티태스킹을 지원한다고 말할 수 있습니다.[^3]
> [!비선점형 커널]
비선점형 커널(non-preemptive kernel)에서는 시스템 호출이나 인터럽트 핸들러가 실행되는 동안 다른 프로세스로 전환할 수 없습니다. 즉, 현재 실행 중인 커널 코드가 명시적으로 `schedule()`을 호출하지 않는 한 다른 프로세스로 바뀌지 않습니다.
## Pageable kernel memory
커널 메모리의 일부(코드, 데이터, 스택, 힙)를 디스크로 스왑할 수 있으면, 해당 커널이 pageable kernel memory를 지원한다고 말할 수 있다.
일반적으로 커널 공간의 메모리는 성능과 안정성 때문에 swap off하지 않습니다.[^4]
> [!swap in과 swap off]
> 프로세스는 페이지 단위로 나눠지며 이를 메모리의 프레임에 적재하는 식으로 동작합니다. 페이지를 메모리에 적재하는 것은 Page in 또는 Swap in이라고 말하며 메모리에서 제거하는 것을 Page out 또는 Swap off라고 말합니다.
## 커널 스택
각 프로세스에는 커널 모드에서 실행되는 동안 시스템 호출의 결과로 함수 호출 체인과 로컬 변수 상태를 유지하는 데 사용되는 커널 스택이 있습니다. 커널 스택은 일반적으로 4KB~12KB로 제한되므로, 커널 개발자는 스택에 큰 구조체를 할당하거나 경계를 고려하지 않은 재귀 호출을 피해야 합니다.
커널 스택은 일반적으로 4KB~12KB로 제한되므로, 커널 개발자는 스택에 큰 구조체를 할당하거나 경계를 고려하지 않은 재귀 호출을 피해야 합니다.
스택 오버플로우가 발생하면 커널 패닉(kernel panic)이 발생할 수 있습니다.
## Portability (이식성)
다양한 아키텍처와 하드웨어 설정에 이식성을 지원하기 위해서 현대의 커널은 다음과 같이 탑레벨에 구성되어 있습니다. 이들을 활용해서 코드의 재사용성을 높입니다.
- Architecture and machine specific code (C & ASM)
- Independent architecture code (C):
    - kernel core (further split in multiple subsystems)
    - device drivers
## Asymmetric MultiProcessing (ASMP)
비대칭 멀티프로세싱(ASMP)는 여러 프로세서(cores)를 커널로 지원하기 위한 방법입니다. 
ASMP에서는 **특정 코어가 커널 전용**으로 예약되고, 나머지 코어는 사용자 공간 프로세스를 실행하는 구조입니다.
단점은 단일 코어를 사용하므로 커널에 처리량이 확장성 있지 않다는 점이다. 예를 들어, system calls, interrupt handling 등이 늘어나더라도 단일 코어에서 모두 처리한다.
![Pasted image 20250213174049.png](/img/user/image/Pasted%20image%2020250213174049.png)
## Symmetric MultiProcessing (SMP)[¶](https://linux-kernel-labs.github.io/refs/heads/master/so2/lec1-intro.html#symmetric-multiprocessing-smp "Permalink to this headline")
SMP는 ASMP와는 달리 어떤 프로세서에서든 커널이 실행될 수 있습니다. 유저 공간에서 실행되는 프로세스처럼 어떤 프로세서에든 할당 가능합니다.
단, 여러 커널이 동시에 실행되면 동기화 이슈(Race condition으로 인한)가 발생할 수 있습니다.
SMP 환경에서는 커널 내에서 스핀락(spinlock) 및 세마포어(semaphore) 같은 동기화 기법이 필수적으로 사용됩니다.
![Pasted image 20250213174355.png](/img/user/image/Pasted%20image%2020250213174355.png)
---
# 참고 자료
- [SO2 Lecture 01 - Course overview and Linux kernel introduction](https://linux-kernel-labs.github.io/refs/heads/master/so2/lec1-intro.html)
# 주석
[^1]: 인터럽트 컨텍스트는 짧은 시간 내에 실행이 끝나야 하는데 `sleep()`과 같은 blocking 함수가 호출되면 안된다.

[^2]: 코어 1개인 상황에서 스레드가 여러 개라면 실제로 연산은 1개의 스레드만 진행된다. 반면에, 코어가 2개라면 연산을 2개씩 처리할 수 있다. 
	프로세스를 빠르게 전환함으로써 프로그램이 마치 동시에 실행되는 것처럼 보이는 것을 동시성(Concurrency)
	프로세스가 실제로 여러 개의 코어에서 병렬적으로 실행된다면 이를 병렬성 (Parallelism)

[^3]: 선점형 멀티태스킹의 기준은 "실행 중인 프로세스를 중단하고 다른 작업을 배치할 수 있느냐"입니다. 따라서, 비선점형 커널은 커널 모드로 실행 중인 프로세스를 중단할 순 없지만 유저 모드로 실행 중인 프로세스를 중단함으로써 CPU를 선점할 수 있으므로 선점형 멀티태스킹을 지원합니다.

[^4]: 커널은 실행이 자주 될텐데 만약, 메인 메모리에 있던 커널 메모리가 보조 기억 장치로 이동했다면(swap off) 페이지 폴트가 발생할 것이다. 페이지 폴트가 발생하면 스왑 오프된 커널 데이터를 메모리에 적재할 필요가 있는데 이는 비용이 큰 작업이다.
