---
{"dg-publish":true,"dg-permalink":"go-in-action-chapter-01","permalink":"/go-in-action-chapter-01/","noteIcon":""}
---

## Tags
- [[03 - Tags/Go in Action\|Go in Action]]
---
``` golang
package main

import "fmt"

func main() {
	fmt.Println("Hello World")
}
```
## 컴파일 시간이 짧다.
- 참조하는 라이브러리만 확인하므로 모든 라이브러리를 참조하는 Java나 C++보다 컴파일 시간이 빠르다.
- 정적 언어이므로 강력한 타입 안정성을 제공한다. (컴파일 시점에서 체크 가능)
## 동시성
- 코루틴을 Kotlin이 coroutine으로 지원하는 것처럼 Golang에선 goroutine으로 동시성 프로그래밍을 제공한다.
- 동시성 기능을 자체적으로 지원하는 `net/http` 라이브러리를 사용하므로 서드 파티 라이브러리를 사용할 필요가 없다.
- 고루틴은 채널(channel) 데이터 구조를 사용하여 고루틴 간에 데이터 전송을 가능하게 만든다.
- 채널은 또한, 동시에 하나의 고루틴만 데이터를 수정 가능하게 만들어 동기화 문제를 해결 가능하다. [^1]
## Go의 타입 시스템
- 합성(Composition) 디자인 패턴을 사용하여, 재사용하는 타입을 임베드(embed)한다.
- 상속이 많은 제약을 주는 것에 비해 `Golang`은 비교적 적은 제약을 가진다.
- 또한, 어떤 인터페이스를 구현하는지 명시할 필요가 없다.[^2]
- Java와 같은 객체지향 언어가 `Entity`를 상속하는 `Customer`를 상속하는 `PassionCustomer`를 정의하여 클래스 간에 강한 의존성을 가지지만, Go는 `Customer`와 `PassionCustomer`를 `Entity` 타입에 임베드 하는 합성 디자인 패턴을 사용한다.
## 메모리 관리
- Garbage Collector 지원
## 내 생각
- 상속을 버린 건 개인적으론 좋은 방향성 같다. 아무 생각 없이 상속했다가 두 개 이상의 클래스가 상속이 불가능하여 문제가 생긴 경험이 있어서
- 언뜻 보기엔 C나 C++ 같은 로우 레벨 언어의 속도와 Pytthon의 코드 간편함 Java처럼 GC를 통해서 메모리 관리를 피하고 Kotlin처럼 내장 라이브러리를 통해 코루틴 지원 등 좋은 점밖에 없는 언어지만 어느 점에서도 반쪽인 느낌도 있다. GC를 가지고 있으므로 C나 C++보다 느릴 것이고. 일단 사용해보자.
---
[^1]: 다른 언어들이 세마포어나 mutex 등 복잡한 방법을 사용하는 것에 비해 훨씬 낫다.
[^2]: 컴파일러가 인터페이스의 타입과 비교한 후에 일치하는지 파악만 한다. 이를 `duck typing`이라고 말한다. 꽥꽥 소리를 내면 오리로 간주하듯이 매개변수와 리턴 타입을 통해서 해당 인터페이스를 구현한다고 보는 것이다.
