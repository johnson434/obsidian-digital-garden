---
{"dg-publish":true,"permalink":"/06-full-notes/2025-02-12/","noteIcon":""}
---

# Tags
- [[06 - Full Notes/2025-02\|2025-02]]
---
# 어제 학습 내용 백지 복습
Terraform 테스트 디렉터리 관련으로 공부함.
디렉터리를 어떻게 나누느냐 고민을 해봤는데 모든 모듈에 tests 폴더를 만드는 건 손이 너무 간다. 손이 너무 가는데 모듈 분리를 위해선 확실히 최고의 방법이다.
통합테스트는 최상단 tests 폴더에서 진행하고 나중에 모듈 분리할 가능성이 높은 애들은 따로 tests 폴더를 만드는 게 맞지 싶다.

별개로 지금 생각나는 내용
컴퓨터 밑바닥의 비밀이란 책을 봤는데 CPU의 연산장치는 단순히 명령어를 레지스터로부터 인출해서 실행하는 역할만 할뿐. 프로세스, 스레드 개념이 없단 거.
프로세스는 스택, 힙, 코드, 데이터 영역으로 나뉘는데 다중 스레드를 사용한다면 스택에서 스레드 개수 만큼 스택 메모리가 생성된다는거 => 이거 생각해보면 당연한 게 스택 영역 자체가 함수 실행을 위한 결과를 저장하는 역할인데 프로그램에서 멀티스레딩을 통해 여러 함수 실행하는 환경이 된다면 각 함수들이 별개로 실행의 흐름을 저장해야됨. 그니까 스택 영역이 따로 여러 개 생기는 게 맞는듯.

컴퓨터 자료구조 운영체제 안본지 오래돼서 생각나는대로 복습하자면
컴퓨터는 메인보드, CPU, 메모리, 보조기억장치
CPU는 연산장치 제어장치(명령어 해석), 레지스터(실행할 명령어를 저장)
메인보드는 버스라는 통로를 통해 데이터를 장치 간에 전송
메모리는 휘발성 저장 장치. 비휘발성 메모리도 개발 중인 걸로 안다.
보조기억장치 SSD HDD SSD는 seek가 없어서 랜덤 Access에 더 유리하다. HDD는 연속된 데이터를 읽는데 유리. 유리하다곤 하지만 SSD가 연속된 데이터 읽는 것도 더 빠름. 그러나 가격 가성비까지 생각했을 때, 연속된 데이터 읽는 속도가 빠른 HDD로 충분하다면 HDD 쓰는 게 낫다 이런 얘기.
프로세스는 실행할 때 유저모드로 실행되고 자원에 대한 접근이 필요할 때, 커널 모드로 들어감. 해당 작업을 끝마치고 나서는 다시 유저 모드로 돌아간다.
운영체제는 스케쥴링, 자원관리, 입출력 등 작업을 맡음.
예를 들어, 아까 말한 CPU가 단순하게 레지스터에 있는 명령어를 인출 후 실행한다고 말했는데 여기 레지스터에 누가 명령어를 적재하냐. 옛날에 운영체제가 없을 땐, 각 소프트웨어가 담당했음. 그러나, 이러면 단 하나의 소프트웨어만 실행 가능함. 아니면 소프트웨어의 제어권을 뺏든가 그런 방법이 있을 수도 있겠지만 이건 내 추측이고.
따라서, 운영체제라는 중간에서 중개역할을 할 프로그램이 만들어진 것.
옛날 타공판이었나 천공판이네.

네트워크 생각나는 거
네트워크 계층을 나눈 건 모듈 별로 분리하여 따로 개발이 가능하도록 만든 것.
갑자기 기억 안나네 OSI 7계층은 세밀하게 나눈 거고 TCP/IP 7계층은 물리 데이터 계층을 합치고 세션 표현 어플리케이션 계층을 합쳐서 물리, 네트워크, 전송, 어플리케이션이라는 4개 계층으로 표현한 거
1계층 물리는 전기 신호 관점. 리피터 등 
2계층 데이터 계층 이더넷 기반 통신 Mac Address 통신 등 비트로 데이터를 전송
3계층 네트워크 계층 IP주소 서로 연결되지 않은 하드웨어끼리 식별하기 위해 사용.
단순하게 서로 연결된 하드웨어면 이더넷 통신으로 통신이 가능하니까 굳이 3계층까지 갈 필요 없으니까
4계층 전송 계층 전송 방식을 지정하는 계층. TCP 세그먼트로 데이터를 전송. 가상회선교환방식으로 가상의 회선이라는 경로를 설정하고 모든 패킷은 해당 경로를 통해서 전송된다. 따라서, 도착 순서가 보장된다.
UDP는 반면에 최적의 경로를 따라서 전송된다. 따라서, 전송 순서를 보장하지 않는다.
세션 표현 Application은 흔히 우리가 아는 Application 개발에서 제어가 가능한 영역. 세션 유지라든가 데이터 표현이라든가 이런 영역.
ARP(Address Resolution Protocol)
기억이 잘안나네. MAC 주소를 스위치에서 브로드캐스팅해서 NIC로부터 응답이 오면 해당 포트에 연결된 하드웨어를 도착지로 판단하는 통신 방법이었나.
RARP(Reverse Address Protocol)
반대로 하는 건데 기억 잘 안남.
SSH(Secure Shell Protocol)
이전에 보안이 되지 않은 telnet 같은 통신을 보완하고자 등장한 프로토콜.
비대칭 암호키를 썼던 걸로 앎. 공개키를 해당 서버에 올리고 클라이언트는 비공개 키를 통해서 서버에 접속하는 걸로.

또 뭐있지
쿠버네티스 클러스터
쿠버네티스가 등장한 이유를 먼저 알아야함.
AWS에선 유휴 서버를 활용하기 위해서 해당 서버를 제공하는 기술을 제공하기 시작함. 이게 클라우드의 시작.
클라우드가 등장하고 클라우드를 효율적으로 사용할 필요가 생겼음.
이전에 온프레미스 환경에선 서버가 유동적으로 늘어나거나 줄어드는 경우가 없었음.
그러나, 클라우드가 등장하고 처리가 불가능한 일시적인 스파이크성 트래픽을 순간적인 수평적 확장으로 처리가 가능해짐. 일시적으로 많은 요청이 들어오면 서버가 추가되어 해당 서버에서 요청을 처리가 가능해짐.
그러나, 또 그러나네. 서버가 늘어나면 이를 위한 프로비저닝 과정이 필요할 것임. 예를 들어서, 특정 포트를 연다거나 nginx를 설치한다거나 자바 스프링을 설치한다거나.
이를 위해서 여러 노드를 유동적으로 관리할 수 있는 말 그대로 노드들을 조율하기 위한 클러스터 오케스트레이션(cluster orchestration)이란 개념이 떠오름.
유동적으로 서버가 늘어나더라도 해당 노드에 자동으로 서비스를 배포해주고 전체 노드를 kube-api server라는 특정 노드(컨트롤 플레인)에서 실행되는 서버 프로그램에서 전체 노드들을 조율함.
또한, 어떠한 노드에 배포가 되더라도 문제가 생기지 않게 즉, 일관적인 동작을 보장하기 위해서 컨테이너라는 기술을 활용함. 
쿠버네티스와 컨테이너의 활용은 단순히 이 기술들이 핫해져서 등장한 게 아님. 정확한 등장 배경을 알고 이해하고 들어가야 된다.
CNCF라는 CloudNative 기술 관련 표준이라고 할 수 있는 단체가 있음. 거기에선 클라우드 생태계 형성을 위한 여러 프로젝트가 있는데 거기서 처음으로 졸업한 프로젝트가 Kubernetes임.

CI/CD란?
Continuous Integration, Continuous Delivery로 지속적 통합과 지속적 배포다.
이렇게 용어로 봐서 어렵지 실은 간단한 개념.
지속적 통합은 우리가 레포지토리에서 진행하는 PR(Pull Request)나 commit 등에 대해서 코드 통합 등을 의미함. 
이거랑 별개로 Linting도 진행함.

지속적 배포는 서비스가 배포되면 자동으로 서비스가 배포되는 것을 의미함.
흔히 CI/CD 툴로 Jenkins나 Github Action을 사용한다.
개인적으로 Jenkins가 나쁘다곤 생각하지 않지만, 개발자 관점에서 간단하게 Repository를 통해서 액션 과정을 체크할 수 있는 Github Action이 나는 더 좋다.
Jenkins는 따로 노드도 띄워야 하고, 유지보수에 비용이 좀 드는 느낌이지만 Github Action은 단순히 스크립트 짜서 레포에 올리면 끝이라.

또 뭐없나. 일단 생각나는 주제 끝

---
# 오후
- [x] 테라폼 어제 작성하던 코드 마저
---