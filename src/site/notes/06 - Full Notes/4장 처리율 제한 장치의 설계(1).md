---
{"dg-publish":true,"permalink":"/06-full-notes/4-1/","noteIcon":""}
---

# Tags
- [[03 - Tags/가상 면접 사례로 배우는 대규모 시스템 설계 기초 1권\|가상 면접 사례로 배우는 대규모 시스템 설계 기초 1권]]

---
# 단서 질문
- 처리율 제한 장치란? 
	- 요청의 제한을 두는 장치. 단위 시간동안 몇회 이상의 요청을 제한하거나 하는 식으로 동작한다.
- 처리율 제한 알고리즘
	- 토큰 버킷 알고리즘(token bucket algorithm)
	- 누출 버킷 알고리즘(leak bucket algorithm)
	- 고정 윈도우 알고리즘(fixed window algorithm)
	- 이동 윈도우 알고리즘
	- 이동 윈도우 카운터 알고리즘
---
# 핵심 요약
- 처리율 제한 장치는 요청 횟수에 대해서 제한을 두는 장치다.
- 클라이언트, 미들웨어, 서버 어느 곳에든 배치할 수 있다.
- 보통 경로 기반으로 처리율 제한이 들어간다. (pathes: [/users, /members...])
- 배치 위치를 정하는 기준은 현재 비즈니스 서비스의 아키텍처나 프로그래밍 언어, 비용, 기술 숙련자 유무 등에 따라 달라진다.
- AWS의 API Gateway도 throttling을 지원한다. 
- AWS의 WAF도 요청 비율 기반 알고리즘으로 요청을 제한할 수 있다.
- 처리율 제한 알고리즘은 여러 가지가 있따.
	- 토큰 버킷 알고리즘
		- 주기적으로 버킷을 충전하는 refiller와 토큰을 저장하는 bucket이 있다.
		- 요청이 들어올 때마다, 버킷에 토큰을 사용한다.
		- 버킷이 비었다면 요청은 반려된다.
	- 누출 버킷 알고리즘
		- 큐 구조로 이뤄진다.
		- 요청이 들어오면 큐로 들어간다.
		- 큐의 크기를 넘어서는 요청은 반려된다.
		- 요청의 처리는 일정 시간을 주기로  반복된다.
	- 고정 윈도우 알고리즘
		- 특정 주기(1분, 1초 등)를 윈도우로 삼고 해당 윈도우의 크기를 지정한다.
		- 윈도우의 크기를 넘는 요청이 들어오면 반려한다.
		- 단, 특정 주기를 기반으로 동작하므로 그 주기 사이에 최대 크기를 넘을 수 있다. 예를 들어, 주기가 1분이면 0분30초부터 1분 30초 사이에 윈도우 크기를 넘는 요청이 올 수 있다.
	- 이동 윈도우 알고리즘
		- 위에 단점을 고친 알고리즘
		- 모든 요청의 타임 스탬프를 Redis의 Sorted Set 같은 곳에 저장한다.
		- 만약, 최대 크기보다 많은 요청이 캐싱되어 있다면 요청을 반려한다.
		- 만료된 요청은(현재 시간 - 시간 주기(1분 등)보다 이전에 들어온 요청) 캐싱에서 제거된다.
		- 메모리가 많이 필요하다.
	- 이동 윈도우 카운터 알고리즘
		- 비율을 통해서 계산한다.
		- 현재 윈도우에 속한 요청의 개수 + 이전 윈도우에 속한 요청의 개수 * 현재 윈도우가 이전 윈도우에 겹치는 비율
		- 메모리가 많이 필요하지 않음.
		- 단, 이전 윈도우 요청 개수를 구하는 공식은 요청이 균등히 왔을 때를 가정했을 때 정확함. 스파이크성 트래픽이 왔다면 공식과 실제 요청 개수의 오차가 클 것. 
		- 단, Cloudfront에서 조사한 결과에 의하면 잘못된 동작을 한 경우가 전체 요청의 0.003%정도라고 함.

---
# 핵심 필기
## 처리율 제한 장치란?
![Pasted image 20250116172547.png](/img/user/image/Pasted%20image%2020250116172547.png)
- 처리율 제한 장치는 특정 기간 내에 들어오는 클라이언트의 요청을 제한하는 장치다. 
- 처리율 제한의 예:
	- 한 IP가 하루동안 가입할 수 있는 계정은 5개
	- 한 유저가 1분에 작성 가능한 포스트 개수를 300개로 제한
	- 한 기계에서 하루동안 받을 수 있는 리워드 개수를 5개로 제한
---
## 처리율 제한 장치를 어디에 두나?
- 클라이언트
	- 위변조가 쉽게 가능하다. 클라이언트 코드는 웬만하면 다 변조가 가능하다.
- 서버
	- 위변조가 불가능하다.
- 미들웨어
	- 서버와 클라이언트 사이에 처리율 제한 장치를 두는 방식
	- AWS에선 WAF을 통해서 구현 가능하다.
	- AWS API Gateway도 경로 기반으로 요청 제한이 가능하다.
위에 선택들은 모두 틀리지 않은 선택지다. 그렇다고 모두가 틀리지 않았으므로 어떤 선택지를 골라도 상관 없지 않다는 얘기가 아니다. 분명 최적의 선택은 있다.
책에선 처리율 제한 장치를 설정할 땐, 다음과 같은 지침을 통해 선택하라고 말한다.
1. 프로그래밍 언어: 서버측에서 구현이 불가능하다면 서버측에 처리율 제한 장치를 둘 수가 없다.
2. 사업에 맞는 처리율 알고리즘: 처리율 제한 알고리즘은 다양하다. 제일 알맞는 알고리즘을 선택해라.
3. 현재 아키텍처: 이미 마이크로서비스 기반 아키텍처를 구성한 상태이며 API Gateway를 아키텍처에 포함시켰다면 API Gateway에 처리율 제한 설정을 두는 건 좋은 방법이 될 수 있다.
4. 시간: 처리율 제한 장치를 직접 개발하는 건 시간이 걸린다. 상용 서비스(AWS에선 WAF나 API Gateway에서 이를 지원한다.) 시간이 없는데 돈은 있다면 상용 서비스를 사용할 것.
---
## 처리율 제한 알고리즘
### 토큰 버킷 알고리즘 (Token Bucket Algorithm)
흔히 쓰이는 알고리즘으로 AWS에서 사용한다. 따라서, 참고할 자료가 많다. 
이름만 보면 무척 어려워보이지만 이름을 이해하면 굉장히 직관적인 알고리즘이다.
토큰 버킷 알고리즘은 토큰, 버킷, 토큰 공급기(refiller)로 이뤄진다.
토큰은 한국어로 동전으로 사용료라고 생각하면 간단하다. 요청할 때마다 버킷에 있는 토큰을 1개 뺀다.
버킷은 양동이로 토큰이 들어있는 곳이다. 주기적으로 토큰 공급기에 의해 채워진다.
![Pasted image 20250201200202.png](/img/user/Pasted%20image%2020250201200202.png)

요청이 들어올 때, 토큰이 없다면 서버는 요청을 차단한다.
![Pasted image 20250201200450.png](/img/user/Pasted%20image%2020250201200450.png)
Bucket 크기는 제한이 있으므로 꽉찬 상태에서 토큰이 공급되면 해당 토큰들은 제거된다.
이처럼 간단한 방식으로 인해 구현이 쉬운 알고리즘이다.
**토큰 버킷의 장점**
- 구현이 쉽다.
- 메모리 사용 측면에서도 효율적이다.
- 짧은 시간에 집중되는 트래픽(burst of traffic)도 처리 가능하다.
**토큰 버킷의 단점**
- 튜닝이 쉽지 않다. Bucket 크기와 토큰 공급률 설정이 필요한데 이 둘을 적절히 설정하기가 까다롭다.
### 누출 버킷 알고리즘(leaky bucket)
토큰 방식과 비슷한 방식으로 큐를 사용한다.
![Pasted image 20250201201726.png](/img/user/Pasted%20image%2020250201201726.png)
1. 요청이 들어오면 큐를 확인한다.
2. 큐가 가득차있다면 요청을 거절한다. 만약, 큐가 가득 차지 않았다면 큐에 요청을 넣는다.
3. 특정 시간마다 큐에서 요청을 꺼내어 처리한다.
전자상거래 쇼피파이(Shopify)가 이 알고리즘을 사용한다.
**누출 버킷의 장점**
- 큐의 크기가 제한되어 메모리 사용량 측면에서 효율적
- 고정된 처리율을 가지므로 안정적 출력(stable outflow rate)이 필요한 경우에 적합하다. (왜냐면 큐의 크기는 일정하고 해당 크기만큼 무조건 처리가 가능한 알고리즘이니까)
**누출 버킷의 단점**
- 단시간에 많은 트래픽이 몰리는 경우 추가로 들어오는 요청은 버려진다.
- `큐의 크기`와 `초당 처리하는 요청 개수` 두 개의 인자를 가지는데 이를 튜닝하기 까다롭다.
### 고정 윈도 카운터 알고리즘(fixed window counter)
윈도우 크기를 지정한다. 윈도우 크기는 단위 시간동안 받을 최대 요청 개수다.
예를 들어서, 1초에 3개의 요청만 받고 싶다면 주기를 1초로 설정하고 윈도우 크기를 3로 설정하면 된다.
![Pasted image 20250201203438.png](/img/user/Pasted%20image%2020250201203438.png)
**고정 윈도우 알고리즘의 단점**은 의도한 요청 횟수 제한보다 많은 요청이 들어올 가능성이 있다.
예를 들어, 0.5초 ~ 1초 사이에 5개 요청이 왔다고 가정하자. 이는 윈도우 사이즈를 벗어나지 않는다. 추가로 1초 ~ 1.5초 사이에 요청이 5개가 왔다고 생각해보자.
위의 예시에서 두 개의 윈도우는 모두 3개라는 임계점을 초과하지 않으므로 버려지는 요청은 없다.
그런데, 시간을 0.5초부터 1.5초로 잡아보면 총합해서 10개의 요청이 온 것을 알 수 있다. 알고리즘을 작성한 사람은 초당 5개의 제한을 넘으면 요청을 버리길 원했지만 시간의 경계 부분에서 예외케이스가 발생하는 것이다.
이러한 단점을 보완한 알고리즘이 이동 윈도우 알고리즘이다.
### 이동 윈도우 로깅 알고리즘
고정 윈도우 로깅 알고리즘의 단점을 보완한 알고리즘으로 어느 시점이든 조건을 만족한다.
구현 방법은 요청마다 윈도우에 타임스탬프를 남기는 것이다. 타임스탬프는 Redis의 Sorted Set과 같은 캐시에 보관하다 만료시간이 되면 제거한다.
만료가 되는 시점은 (현재 시간 - 윈도우의 시간)보다 작으면 만료가 된다. 
예를 들어서, 1분당 요청 횟수를 제한한다면 30초에 들어온 요청은 1분 30초가 지나면 캐시에서 타임스탬프를 제거한다.
이 방법의 핵심은 거부당한 요청도 캐시에 기록한다는 점이다.
![Pasted image 20250201211330.png](/img/user/Pasted%20image%2020250201211330.png)
1. 01초에 들어온 요청은 전송된다.
2. 30초에 들어온 요청도 캐싱 사이즈가 2개를 넘지 않으므로 전송된다.
3. 50초에 들어온 요청은 캐싱 사이즈를 넘으므로 전송되지 않는다.
4. 1분 20초에 요청이 들어왔으며 01초에 들어온 요청의 캐싱은 지워진다. 여전히 캐싱 크기를 넘으므로 전송되지 않는다.
5. 1분 55초에 요청이 들어왔으며 추가적으로 30초, 50초 요청의 타임스탬프가 캐싱에서 지워진다. 따라서, 요청 개수가 2개를 넘지 않으므로 요청은 전송된다.
**이동 윈도우 알고리즘의 장점**
- 어느 시점에서도 요청 개수 제한을 넘지 않는다. 시간 경계에 요청이 많이 들어와도 모든 요청의 타임스탬프를 기반으로 제한을 두므로 절대적으로 개수 제한을 보장한다.
**이동 윈도우 알고리즘의 단점**
- 많은 메모리 공간을 요구한다. (실패한 요청의 타임스탬프도 기록하므로)
- 위에 예시를 보자면 Redis 캐싱 서버가 필요하고 부가적인 작업이 많이 필요하다.
### 이동 윈도우 카운터 알고리즘
고정 윈도우 알고리즘과 이동 윈도우 알고리즘의 방식을 결합한 방식.
현재 진행 시간을 생각하여 이전 윈도우의 비율을 계산하여 더하는 알고리즘이다.
즉, `현재 1분 주기 윈도우에 포함된 요청 개수` + `이전 1분 주기 윈도우에 포함된 요청 개수` * `현재 윈도우가 이전 윈도우에 포함된 비율`이다.
예시를 들어보자. 1분동안 최대 5개 요청을 받는 서비스가 있다고 하자.
윈도우 크기는 5개로 잡을 것이며 주기는 1분이 될 것이다.
0분 ~ 1분 사이에 요청이 3개가 왔다고 가정한다.
현재 시각은 1분 20초이며 1분 ~ 1분 20초 사이에 2개 요청이 왔다.
이렇게 되면 계산식은 아래와 같다.
$$ 2 + 3 * (40/60)= 4$$
20초가 지났으므로 40초는 이전 윈도우에 포함된 비율이다. 따라서, `2/3`을 이전 1분 윈도우에 요청 개수에 곱한다. 따라서, 현재 요청 개수는 4개이므로 요청을 1개 받을 수 있다.

**이동 윈도우 카운터 알고리즘의 장점**
- 메모리 효율이 좋다.
- 어느 시간대를 집어도 요청 개수 제한을 넘지 않는다.(고정 윈도우는 넘었음)
**이동 윈도우 카운터 알고리즘의 단점**
- 비율을 계산하므로 요청이 균등하지 않으면 예상했던 결과와 다를 수 있다. 
단점을 예시를 들어 설명해보겠다. 예를 들어서, 10초 대에 스파이크성 트래픽이 들어왔다. 요청의 개수가 200개라고 가정해보자. 이후에 요청은 일절 들어오지 않았다.
1분 20초에 이동 윈도우 카운터 알고리즘을 도입해서 현재 요청을 더 받을 수 있는지 계산해보겠다.
1분 ~ 1분 20초 사이에 요청이 30개 들어왔다고 가정하겠다. 결과는 다음과 같다.
$$ 30 + 200 * (1/3) ≈ 93.666$$
10초 이후부터1분까진 요청이 일절 들어오지 않았지만 비율로 판단하기 때문에 상당히 많은 요청이 1분동안 들어온 것으로 결과가 나온다.
위에 예시를 보면 엄청 심각해보이지만, Cloudflare에서 조사한 바에 따르면 이동 윈도우 카운터 알고리즘을 통해서 버려지면 안되는데 버려진 요청이나 허용 되면 안되는데 허용된 요청의 비율은 전체 요청의 0.003%라고 하니 안심해도 된다.


---
# 참고 자료





