---
{"dg-publish":true,"permalink":"/06-full-notes/2025-03-04/","noteIcon":""}
---


# Tags
- [[03 - Tags/2025-03\|2025-03]]
---
# 어제 학습 내용 백지 복습
어제 쉼.
LoadAverage는 현재 Queue에서 대기 중인 프로세스의 개수.
프로세스란? 하드웨어 리소스 등 프로그램을 실행하는데 필요한 모든 리소스들을 OS에서 추상화한것.
ns_proxy는 새로운 프로세스가 생기면 새로운 네임스페이스를 해당 네임스페이스와 연결한다.
따라서, 서로 다른 네임스페이스끼리는 직접적인 통신이 불가능하므로 컨테이너 간에 격리가 가능해진다.
컨테이너에 내부 접속해서 ps aux를 하거나 /proc를 가보더라도 다른 컨테이너의 pid가 뜨지 않는이유. 
네트워크도 네임스페이스를 통하여 격리되어 분리된다.
호스트와 통신은 veth라는 서로 다른 네트워크 네임스페이스를 통신하는 기술을 사용. veth는 단순하게 이더넷을 서로의 네트워크 네임스페이스에 만들어서 전송. 이를 리눅스 브릿지에서 받아서 커널에 전달한다.
커널엔 이더넷, conntrack, iptable(nftable은 더 최신이다. rule을 정하여 커널 내로 들어오는 패킷을 Allow or Deny 가능), 또 뭐 하나 있었는데.
쿠버네티스의 네트워킹도 위와 같은 방식으로 동작. 예를 들어, network policy는 iptable을 통해 구현됨. 따라서, kubernetes 직원은 kubernetes도 단순한 리눅스라고 말한다.
실제로 Pod에 IP가 배포되며 서비스를 통한 서비스 엔드포인트가 pod와 연결되는 것도 kube-proxy가 routes를 수정하기 때문에 가능한 것.
kube-proxy라는 외부에 서버가 뜨는 그런 게 아님. routes를 수정하는 거.
VPC CNI가 이러한 Pod의 IP를 VPC에 할당하여 오버레이 네트워크를 하지 않고 언더레이 네트워크로 동작함. 따라서, 헤더가 덜붙는다. -> 통신이 더 빠르다.
커널은 유저모드, 커널모드, 
추상화는 user process <-> System call interface <-> Kerenel <-> Driver <-> 하드웨어
커널 잘 기억 안나니 보충 필요할덧.
마이크로 커널이랑 모놀리식 커널이 있음. 모놀리식 커널은 파일 서비스랑 네트워크 서비스를 커널로부터 분리. 파일 서비스에 문제가 발생해도 커널에 영향이 적다. 커널 패닉 방지.

---
# 오전
- [x] 구름 OT
---
# 오후
- [x] 구름 OT
- [x] 끝나고 Ansible 공부
---
# 오늘 학습 내용 백지 복습
Ansible 공부함. Ansible inventory 정의.
변수는 선언하면 전역, 부모그룹, 자식그룹, 호스트 변수 순으로 덮어씌워짐. 나중으로 갈수록 덮어씌워지는거임. 어떻게 보면 단연한게 css 인라인 스타일이 우선도가 가장 높듯이 가장 가까운 변수가 우선되는 게 맞지.
Ansible serial을 통해서 동시 작업 가능한 호스트 개수 조절 가능.
모든 서버가 다운되면 안되는 작업에 유용할듯.
동적으로 인벤토리 설정 가능하다.

---
# 하루를 마치며
구름OT하느라 공부하는 시간이 부족함. 지금 12시인데 시간 꽤 썼는데도 그렇게 많이 진도 못뺌.
AWS 문서 작성했던 거 빨리 수정 완료하고 Ansible, Terraform 수정하자.

---
# 내일 할 일
Ansible 일단 끝내고, 테라폼 코드 작성하기가 목표인데.
근데 문제는 구름 수업이 어떻게 될지 봐야할덧. 일단 내일 상황 보자
Ansible: 인벤토리 끝내기
Terraform: environment 별로 main.tf 파일 나누기
DevOps와 SE를 위한 리눅스 커널 이야기: 1장 ~ 3장 요약(이미 읽음)
AWS 16강: 
이거 위에 절대 전부다 못할텐데. 일단, 쟤네가 제일 급한 애들.
일단 자기 전에 리눅스 커널 이야기 복습하고 시간 남으면 마저 읽어야겠다. 굉장히 도움이 많이되는 책같다.


---