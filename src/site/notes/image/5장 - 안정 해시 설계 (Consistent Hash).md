---
{"dg-publish":true,"permalink":"/image/5-consistent-hash/","noteIcon":""}
---

# Tags
- [[03 - Tags/가상 면접 사례로 배우는 대규모 시스템 설계 기초 1권\|가상 면접 사례로 배우는 대규모 시스템 설계 기초 1권]]
---
# 단서 질문
- DB를 수평적 스케일링 하는 방법은?
	- 샤딩: 해싱을 통해 서로 다른 DB에 데이터를 나누어 저장한다.
	- 샤딩 단점:  조인이 힘들어진다.
- 안정 해시 알고리즘의 단점은?
	- 가상 노드를 저장할 필요가 있다.
---
# 핵심 요약
- 샤딩 기법은 수평적 스케일링을 위해서 데이터를 인스턴스 마다 나눠서 저장하는 방법이다.
- 저장할 인스턴스를 선택하는 방법은 데이터의 `key`를 `hashing` 알고리즘에 대입하는 것이다.
- hashing 알고리즘 중에서 재샤딩으로 인한 여파가 크지 않은 알고리즘이 안정 해시 알고리즘 (consistent algorithm)이다. 
- 해시링에 노드를 배치하고, 해싱을 통해 키가 배치되면 시계방향으로 가장 먼저 만나는 노드에 데이터를 저장한다.
- 단점으로 해싱 알고리즘을 통해 분배되는 파티셔닝 크기가 다를 수 있다. 즉, 각 DB 인스턴스에 저장되는 데이터의 양이 균등하지 않을 수 있다.
- 이를 해결하기 위해 가상노드(virtual node) 방법을 사용한다.
- 하나의 노드를 논리적인 여러 개의 가상 노드로 나눈다. 이를 통해서 모집단이 커지면 표준 편차가 작아져 각 DB가 비슷한 데이터 양을 저장할 수 있다.
---
# 핵심 필기
## 샤딩 기법에서 데이터 재분배 문제
이전에 Database의 수평적 확장 측면에서 샤딩[^1]을 공부했다. 특정 key를 기반으로 해싱 함수를 적용하여 데이터가 저장될 DB 인스턴스를 지정하는 방법이다.
아래는 클라이언트 번호를 해싱 키로 사용하며 `(클라이언트 번호) % (데이터베이스 전체 개수)` 알고리즘을 해싱 함수로 사용하는 예제다.

**샤딩 예제**
![Pasted image 20250222231626.png](/img/user/image/Pasted%20image%2020250222231626.png)
이러한 샤딩 기법에는 데이터베이스의 재분배 시에 문제가 발생한다.
예를 들어, Database 인스턴스 중에 특정 인스턴스가 죽었다고 가정해보자. 구체적으로 1번이 죽었다고 가정해보겠다.

**데이터베이스 인스턴스 1번이 죽었다고 가정**
![Pasted image 20250222231644.png](/img/user/image/Pasted%20image%2020250222231644.png)
1번 데이터베이스 인스턴스가 죽으면 이후에 어떻게 될까? 여기선 장애가 발생한 DB의 데이터를 타 데이터베이스로 이전하는 DR이 구성 되었다고 생각해보겠다.[^2]

**DR을 통해서 장애 인스턴스의 데이터가 타 데이터베이스로 이전**
![Pasted image 20250222231658.png](/img/user/image/Pasted%20image%2020250222231658.png)
장애가 발생한 인스턴스의 데이터가 이전되면 모든 문제가 해결이 될까? 아니다. 

**특정 데이터 조회 시 문제 발생**
![Pasted image 20250222231710.png](/img/user/image/Pasted%20image%2020250222231710.png)
웹서버의 해싱 기법은 바뀌지 않았다. 번호가 1번인 James의 정보를 조회해보자.
"James"가 0번 인스턴스로 이전했음에도 불구하고 서버는 1번 인스턴스로 요청을 보낸다.
따라서, 우리는 리샤딩이 일어나도 안정적으로 DB를 조회할 수 있는 **안정 해시(consistent hash) 알고리즘**이 필요한 것이다.
## 안정 해시 (Consistent Hash)
안정 해시는 `k/n`개의 키만 재배치하는 해시 기술이다. 여기서 n은 슬롯의 개수이며 k는 키의 개수이다. 이게 뭔 소리야 싶지만 뒤에 가면 감이 온다.
### 해시 공간과 해시 링
안정 해시에 구현 방법이다. 이번 예제에선 **안정 해싱 알고리즘으로 `sha-1`을 사용**할 것이다.[^3]
`sha-1` 알고리즘은 160비트를 사용한다. (범위가 0 ~ 2^160 - 1)
`sha-1` 해싱 알고리즘을 통해 표현할 수 있는 데이터 범위가 160비트이므로 테이블의 크기도 160비트가 될 것이다.
![Pasted image 20250221165348.png](/img/user/image/Pasted%20image%2020250221165348.png)

**해시 서버 배치**
해시 링에 Database 인스턴스들을 배치할 것이다. 이전에도 말했듯이 `sha-1` 해싱 알고리즘을 사용할 것이다. 해싱 알고리즘의 키값으로는 어떤 값이 와도 좋지만, Unique한 값을 사용한다.[^4]
![Pasted image 20250221130229.png](/img/user/image/Pasted%20image%2020250221130229.png)

**해시 키 배치**
이제 저장할 데이터를 해싱 함수를 적용하여 해시링에 배치할 것이다.
key값으로는 이름을 주겠다.
![Pasted image 20250221130717.png](/img/user/image/Pasted%20image%2020250221130717.png)

**서버 조회**
이제 키를 검색할 때, 어떤 서버에서 조회가 필요한지 결정하는 부분이다.
간단하다. 검색할 키가 시계방향을 돌면서 제일 먼저 만나는 서버에서 데이터 조회가 가능하다.
![Pasted image 20250222232303.png](/img/user/image/Pasted%20image%2020250222232303.png)
시계 방향 1시에 `James`, `Mark`는 제일 먼저 `db1`을 만난다. 따라서, 해당 `db1`에 저장된다.
이와 같은 방식으로 `Henry`는 `db2`에 `KimChulsiu`는 `db0`에 저장된다.

**서버 추가**
![Pasted image 20250222232508.png](/img/user/image/Pasted%20image%2020250222232508.png)
다음은 DB의 조회가 늘어나서 `db3` 인스턴스가 추가된 상황이다.
해싱을 통해 서버가 해시링에 배치되며, `db1`에 속했던 "James"가 `db3` 서버로 재배치된다. 
여기서 k/n만큼 재배치 된다는 의미가 이해됐다. 전체 슬롯인 3개에서 전체 키의 개수 4개. 즉, 4/3 ≈ 1개가 재배치 된다는 뜻이다.
다른 알고리즘은 해싱이 바뀌면 거의 모든 데이터가 재배치 되는 것에 비해 안정 알고리즘은 효율적으로 최소한의 데이터만 재배치 한다.

**서버 제거**
`db2`에 장애가 발생하여 서버가 제거되었다고 가정해보겠다.
![Pasted image 20250222232933.png](/img/user/image/Pasted%20image%2020250222232933.png)
`db2`에 저장되어 있던 "Henry"는 시계 방향으로 만나는 첫 번째 서버인 `db0`로 이전한다.
### 기본 구현법의 두 가지 문제
결론적으로 두 가지 문제 모두 해싱 알고리즘을 통해 나오는 결과 값이 균일하게 배치되지 않는다는 점에서 나왔다.
첫 번째 문제는 서버의 파티셔닝의 크기가 달라진다.
두 번째 문제는 데이터를 균등하게 저장할 수 없다.

우선, 첫 번째 문제부터 알아보겠다. 아까 서버를 배치하는 예제에선 서버들이 아주 이쁘게 120도씩 딱 나눠졌다. 하지만, 실제로 그렇게 배치가 이뤄질까? 아래는 극단적인 예시를 가져왔다.
![Pasted image 20250221133840.png](/img/user/image/Pasted%20image%2020250221133840.png)
해싱을 통해 배치된 서버에 위치가 서로 멀지 않은 곳에 배치됐다. 위와 같은 상황에서 문제는 무엇일까? 바로 `db0`이 관할하는 영역이 다른 `db1`, `db2`에 비해 매우 크다는 점이다. 
위와 같이 데이터베이스가 배치된다면 대부분의 데이터가 `db0`에 저장 및 조회가 될 것이다.

다음으로, 두 번째 문제인 데이터가 균등하게 저장되지 않는다는 점이다.
![Pasted image 20250221134310.png](/img/user/image/Pasted%20image%2020250221134310.png)
극단적인 예시지만, 위처럼 해싱 함수를 통해 특정 서버에 한정해서 데이터가 집중되어 저장될 수도 있다.

이러한 문제점들을 해결하기 위해 만들어진 구현 방법이 가상 노드(virtual node) 또는 복제(replica)라 불리는 기법이다.

### 개선된 안정 해시 구현 방법: 가상 노드
가상 노드란 하나의 서버가 여러 개의 가상 노드를 해싱 링에 배치하고 해당 가상 노드들이 맡는 영역을 실제 서버가 처리하는 방법이다.
이게 직관적으론 와닿는데 객관적으로 설명이 불가능해서 내 나름대로 설명을 써보겠다.

**서버가 1대일 때**
![Pasted image 20250221145518.png](/img/user/image/Pasted%20image%2020250221145518.png)
필연적으로 한 대의 서버가 모든 데이터를 저장할 것이다. 여기서 서버가 추가된다면 어떻게 될까?

**서버가 2대일 때**
![Pasted image 20250221162449.png](/img/user/image/Pasted%20image%2020250221162449.png)
해싱을 통해 파티셔닝이 되었지만, 불균형하게 되어 `db0`이 차지하는 영역이 많다.
여기서 서버가 4대 추가되었다고 보자.

**서버가 6대일 때**
![Pasted image 20250221162758.png](/img/user/image/Pasted%20image%2020250221162758.png)
해싱을 통해 위처럼 파티셔닝이 되었다. 서버의 개수가 늘어날수록 집단의 편차가 작아지는 것을 볼 수가 있다.
서버의 개수가 10대, 100대, 200대가 되면 편차는 점점 작아진다.
과거에 확률과 통계 시간에 분산을 배운 기억이 있을 것이다. 
$$
\sigma = \sqrt{\frac{\sum_{i=1}^{N} (x_i - \mu)^2}{N}}
$$
여기서 N은 모집단의 개수가 되며, 모집단의 개수가 커질수록 표준편차는 작아지는 게 기억날 것이다.
가상 노드는 이러한 모집단의 개수가 커질수록 표준편차가 작아지는 것을 이용한 방법이다. 단, 물리적으로 서버를 증가시키는 것이 아니라 가상의 노드를 생성하여 표본의 크기를 늘리는 것이다.
다시 처음으로 돌아가서 DB가 2대 있다고 가정해보겠다.

**DB가 2대일 때**
![Pasted image 20250221164304.png](/img/user/image/Pasted%20image%2020250221164304.png)
모수가 작아서 편차가 큰 것을 볼 수 있다. 여기서 가상의 노드를 배치하여 모수의 크기를 증가시키는 것이다.

**가상 노드 8대로 대체**
![Pasted image 20250221164730.png](/img/user/image/Pasted%20image%2020250221164730.png)
`db-00`은 모든 `가상노드00_`을 포함한다.
`db-01`은 모든 `가상 노드01_`을 포함한다.
실제 서버는 `db-00`과 `db-01` 두 대 뿐이지만 가상 노드를 설정함으로써, `db-00`과 `db-01`에 저장되는 데이터의 양이 어느 정도 양분할 수 있게 됐다.

가상 노드의 값이 커질수록 표준편차는 작아지므로 가상 노드를 무한하게 설정하면 되지 않을까 생각할 수도 있다. 그러나, 가상 노드의 값도 저장이 필요하다는 걸 고려할 필요가 있다.
즉, `가상노드의 개수를 늘림으로써 얻을 수 있는 작은 표준 편차` vs `가상 노드의 개수가 늘어남으로써 일어나는 부작용`을 생각하고 적절한 선에서 타협할 필요가 있다.
참고로 이 안정 해시는 당연하게도 오직 DB를 위한 방법이 아니다.
로드밸런싱에 이용이 가능하다. [^5]

---
# 참고 자료
- 가상 면접 사례로 배우는 대규모 설계 1권 - 해시 키 재배치(rehash) 문제
---
# 주석
[^1]: 데이터베이스의 특정 key를 기준으로 해싱 함수를 적용하여 저장될 Database를 지정하는 방법. 이 때, 사용된 key를 해싱 키라고 부른다.
[^2]: DB의 장애 발생 시에 대응 전략은 여러 가지가 있다. Active-Active 구조라면 바로 ReadOnly 인스턴스가 Master DB가 될 것이고, Active-StandBy 구조라면 StandBy DB가 Active로 상태가 변경될 것이다. 여기선, 안정해싱에 대해 설명하기 위해서 해당 DB의 데이터를 타 DB로 이전하는 상황을 가정했다.
[^3]: sha-1 데이터 암호화를 위해 개발된 알고리즘이다. 현재는 데이터 암호화에 권장하지 않는 방식이다. 최근엔 sha-2(ex: sha-256, sha-512 등)를 권장한다.
[^4]: Unique하지 않은 값이라면 서로 다른 두 개의 서버가 동일한 해시 링에 배치될 것이기 때문이다
[^5]: 간단하게 db가 웹서버 컨테이너 혹은 요청을 보낼 EC2로 생각하고 key를 request라고 생각하자. request를 hashing을 통해서 해싱링에 배치하고 시계 방향으로 돌면서 가장 가까운 웹서버에 요청을 보낸다.